#!/usr/local/bin/wish -f

set initialized 0

#
# Canvas display variables.
#
set site_height             25
set site_width              25
set x_gap                    5
set y_gap                    5

#
# Time variables.
#
set displayed_generation     0
set ngenerations            -1
set time_delay               0
set stop_button              0

#
# Color variables.
#
set level_width             20
set level_height            10
set nlevels                 10
set levels_scale_exponent    1.0
set levels_scale_multiplier  1.2

#
# Population variables.
#
set max_population          -1
set world_population         0
set total_pop_sizes(0)       0

#
# Controls whether the generation scale updates when playing.
#
set update_slider            1

#
# Convenient names for widgets.
#
set canvas  .f.canvas
set scale   .f.scale

#
# Stuff for colors.
#
set ncolors                  32
set color_interval           1437
set ncolors                  64
set color_interval           718
set colors(0)                red

if {$argc == 0} {
  puts "Reading from stdin..."
  set f stdin
} else {
  set filename [lindex $argv 0]
  set f [open $filename r]
}

proc get_color {intensity} {
  global colors ncolors

  #puts "get_color($intensity)"
  return $colors([expr int($intensity * $ncolors)])
}

proc set_colors {ncolors interval} {

  global colors

  set x 65535
  #frame .f.colors
  
  for {set i 0} {$i <= $ncolors} {incr i} {
    set colors($i) [format "#ffff%04x0000" $x]
    #button .f.colors.$i -bg $colors($i) -text "$x $colors($i)"
    incr x -$interval
    #pack .f.colors.$i
  }

  #pack .f.colors -side left
}

proc initialize {} {

  set menu    .f.menu
  set play    .f.play
  set info    .f.info0
  set info1   .f.info1

  global f canvas canvas_height canvas_width stop_button \
    displayed_generation ngenerations scale pop nsites \
    level_width level_height nlevels world_population site_width

  wm title . "Echo Population Viewer"
  wm minsize . 1 1
  if {[file exists "bitmaps/jhh_smaller.bm"]} {
    wm iconbitmap . @bitmaps/jhh_smaller.bm
  }
  wm iconname . "Ants, flies and caterpillars!"


  frame .f
  pack .f
  
  # .f.view holds the canvas and play buttons.
  frame .f.view

  canvas $canvas -height $canvas_height -width $canvas_width -relief raised

  bind all r  {plot_generation 0 1}
  bind all ,  {backward_generation}
  bind all s  {set stop_button 1}
  bind all .  {forward_generation}
  bind all p  {play_generations $displayed_generation [expr $ngenerations - 1]}
  bind all f  {plot_generation [expr $ngenerations - 1] 1}
  bind all q  {destroy .}

  frame .f.levels -borderwidth 2 -relief groove

  frame .f.levels.b1
  frame .f.levels.b2

  button .f.levels.b11 -bitmap @bitmaps/rplay.bm   -command {narrow_levels_range} -fg grey
  #button .f.levels.b12 -bitmap @bitmaps/rplay.bm   -command {narrow_color_range} -fg grey
  button .f.levels.b21 -bitmap @bitmaps/play.bm -command {widen_levels_range}  -fg grey
  #button .f.levels.b22 -bitmap @bitmaps/play.bm -command {widen_color_range}  -fg grey

  pack .f.levels.b11 -padx 6 -in .f.levels.b1
  pack .f.levels.b21 -padx 6 -in .f.levels.b2

  pack .f.levels.b1 -in .f.levels -side left -pady 10

  for {set i 0} {$i < $nlevels} {incr i} {
    frame  .f.levels.$i
    label  .f.levels.$i.label  -width 2 -text $i
    canvas .f.levels.$i.canvas -width $level_width -height $level_height -bg grey

    pack   .f.levels.$i.label  -in .f.levels.$i -fill y
    pack   .f.levels.$i.canvas -in .f.levels.$i -fill y
    pack   .f.levels.$i        -in .f.levels    -side left
  }

  pack .f.levels.b2 -in .f.levels -side left -pady 10

  frame $info -relief raised -borderwidth 1
  frame $info.left
  frame $info.right

  label $info.left.1 -text "Generation Number"
  label $info.left.2 -text "Generations Recorded"
  label $info.left.3 -text "World Population"

  label $info.right.1 -textvariable displayed_generation -width 5 -relief sunken
  label $info.right.2 -textvariable ngenerations         -width 5 -relief sunken
  label $info.right.3 -textvariable world_population     -width 5 -relief sunken

  pack $info.left.1  $info.left.2  $info.left.3  -side top -in $info.left  -anchor w
  pack $info.right.1 $info.right.2 $info.right.3 -side top -in $info.right -anchor e

  pack $info.left  -side left -in $info -fill x
  pack $info.right -side left -in $info

  frame $play -relief groove -borderwidth 2

  button $play.rewind -bitmap @bitmaps/rewind.bm       -padx 10 -fg grey \
    -command {plot_generation 0 1}
  button $play.rplay  -bitmap @bitmaps/rplay.bm        -padx 10 -fg grey \
    -command {play_generations $displayed_generation 0}
  button $play.rplay1 -bitmap @bitmaps/rplay1.bm       -padx 10 -fg grey \
    -command {backward_generation}
  button $play.stop   -bitmap @bitmaps/stop.bm         -padx 10 -fg grey \
    -command {set stop_button 1}
  button $play.play1  -bitmap @bitmaps/play1.bm        -padx 10 -fg grey \
    -command {forward_generation}
  button $play.play   -bitmap @bitmaps/play.bm         -padx 10 -fg grey \
    -command {play_generations $displayed_generation [expr $ngenerations - 1]}
  button $play.ffwd   -bitmap @bitmaps/fast_forward.bm -padx 10 -fg grey \
    -command {plot_generation [expr $ngenerations - 1] 1}

  set play_buttons "$play.rewind $play.rplay $play.rplay1 $play.stop $play.play1 $play.play $play.ffwd"

  eval pack $play_buttons -side left -pady 10 -in $play

  scale $scale -orient horizontal -relief raised -command "goto_generation" -from 0 -to 100 \
    -label "Generation Selector" -showvalue 1

  scale .f.sidescale -orient horizontal -relief raised -command "destroy_sites" -from 1 -to 50 \
    -label "Site Size" -showvalue 1
  .f.sidescale set $site_width

  button .f.dismiss -bg seagreen -fg white -text "Dismiss" -command {destroy .} -relief raised
  
  frame $menu -relief raised -borderwidth 1

  pack $menu        -side top  -fill x -in .f
  pack $info        -side top  -fill x -in .f.view
  pack $scale       -side top  -fill x -in .f.view
  pack .f.sidescale -side top  -fill x -in .f.view
  pack $canvas -in .f.view
  pack $play -in .f.view
  pack .f.levels -in .f.view
  pack .f.view -in .f

  #
  # The Files menu.
  #
  menubutton .f.menu.files -text Files -menu .f.menu.files.m -underline 0
  menu .f.menu.files.m

  if {$f != "stdin"} {
    .f.menu.files.m add command -label "Re-read" -command {read_input} -underline 0
  }
  .f.menu.files.m add command -label "Open" -command {puts "read file"} -underline 0
  .f.menu.files.m add command -label "Print Canvas..." -command {print_canvas} -underline 0
  .f.menu.files.m add command -label "Quit" -command {destroy .} -underline 0
  
  #
  # The Time menu.
  #
  menubutton .f.menu.time -text Time -menu .f.menu.time.m -underline 0
  menu .f.menu.time.m
  .f.menu.time.m add command -label "Jump To Generation..." -command {puts "Jump"} -underline 0
  .f.menu.time.m add separator
  .f.menu.time.m add radio -label "Slow" -variable time_delay -value 800
  .f.menu.time.m add radio -label "Medium" -variable time_delay -value 400
  .f.menu.time.m add radio -label "Fast" -variable time_delay -value 0
  
  pack .f.menu.files .f.menu.time -side left

  set a -1
  set pop($a) [list -1]
  for {set i 0} {$i < $nsites} {incr i} {
    lappend $pop(-1) -1
  }
}



proc draw_sites {} {
  global canvas rows cols site_height site_width x_gap y_gap

  for {set row 0} {$row < $rows} {incr row} {
    for {set col 0} {$col < $cols} {incr col} {

      set x1 [expr $x_gap + $col * ($x_gap + $site_width)]
      set y1 [expr $y_gap + $row * ($y_gap + $site_height)]
      set x2 [expr $x1 + $site_width]
      set y2 [expr $y1 + $site_height]

      # puts "($x1, $y1) ($x2, $y2)"
      set tag s.[expr $row * $cols + $col]

      $canvas create rectangle $x1 $y1 $x2 $y2 -fill grey -outline black -tags $tag
    }
  }
}

proc destroy_sites {size} {
  global canvas site_height site_width site_height displayed_generation initialized \
    canvas_height canvas_width

  if {$initialized == 0} {
    return
  }
  
  $canvas delete all

  set_canvas_dimensions $size
  
  $canvas configure -width $canvas_width -height $canvas_height
  
  draw_sites
  plot_generation $displayed_generation 0
  update
}


proc name_and_color_levels {} {

  global max_population nlevels .f levels_scale_exponent displayed_generation colors ncolors

  # set inc [expr $max_population / $nlevels]

  for {set i 0} {$i < $nlevels} {incr i} {
    set level [expr int(pow($i, $levels_scale_exponent))]

    if {$level > $max_population} {
      set level $max_population
    }
    
    #.f.levels.$i.canvas configure -bg $colors([expr int($level / $max_population * $ncolors)])
    .f.levels.$i.canvas configure -bg [get_color [expr ${level}.0 / ${max_population}.0]]
    .f.levels.$i.label  configure -text $level
  }

  plot_generation $displayed_generation 1
}

proc narrow_levels_range {} {
  global levels_scale_exponent levels_scale_multiplier

  set levels_scale_exponent [expr $levels_scale_exponent * $levels_scale_multiplier]
  name_and_color_levels
}

proc widen_levels_range {} {
  global levels_scale_exponent levels_scale_multiplier

  set levels_scale_exponent [expr $levels_scale_exponent / $levels_scale_multiplier]

  if {$levels_scale_exponent < 1.0} {
    set levels_scale_exponent 1.0
  }

  name_and_color_levels
}

proc read_rows_cols {} {

  global f nsites canvas_height canvas_width rows cols x_gap y_gap site_height site_width

  if {[gets $f rows] < 0} {
    puts stderr "Could not read number of rows!"
    exit
  }

  if {[gets $f cols] < 0} {
    puts stderr "Could not read number of cols!"
    exit
  }

  set nsites [expr $rows * $cols]

  set_canvas_dimensions $site_width
}

proc set_canvas_dimensions {side} {

  global canvas_height canvas_width rows cols x_gap y_gap site_height site_width

  set site_height $side
  set site_width $side
  
  set canvas_height [expr $y_gap * ($rows + 1) + $site_height * $rows]
  set canvas_width [expr $x_gap * ($cols + 1) + $site_width * $cols]
}



proc read_input {} {

  global f ngenerations nsites pop total_pop_sizes max_population scale

  while {[gets $f line] >= 0} {
    
    incr ngenerations

    set pop($ngenerations) [split $line { }]

    if {[llength $pop($ngenerations)] != $nsites + 2} {
      puts "Found line with [llength $pop($ngenerations)] site populations instead of $nsites"
      break
    }

    set total_pop_sizes($ngenerations) [lindex $pop($ngenerations) $nsites]

    set max_gen_pop [lindex $pop($ngenerations) [expr $nsites + 1]]
    if {$max_gen_pop > $max_population} {
      set max_population $max_gen_pop
    }

    update
  }

  #puts "max pop size is $max_population"
  name_and_color_levels
  $scale configure -to $ngenerations
}

proc plot_generation {generation lazy} {

  global displayed_generation pop rows cols canvas scale update_slider \
    world_population total_pop_sizes nsites colors ncolors max_population

  for {set i 0} {$i < $nsites} {incr i} {
    if {$lazy == 1} {
      if {[lindex $pop($displayed_generation) $i] != [lindex $pop($generation) $i]} {
	$canvas itemconfigure s.$i -fill \
	  [get_color [expr [lindex $pop($generation) $i].0 / ${max_population}.0]]
	#$colors([expr int([lindex $pop($generation) $i] / $max_population * $ncolors)])
      }
    } else {
      $canvas itemconfigure s.$i -fill \
	[get_color [expr [lindex $pop($generation) $i].0 / ${max_population}.0]]
      #$colors([expr int([lindex $pop($generation) $i] / $max_population * $ncolors)])
    }
  }

  set displayed_generation $generation
  set world_population $total_pop_sizes($generation)

  if {$update_slider == 1} {
    $scale set $generation
  }

  update
}

proc goto_generation {gen} {
  plot_generation $gen 0
}


proc backward_generation {} {
  global displayed_generation

  if {$displayed_generation != 0} {
    plot_generation [expr $displayed_generation - 1] 1
  }
}

proc forward_generation {} {
  global displayed_generation ngenerations

  if {$displayed_generation != [expr $ngenerations - 1]} {
    plot_generation [expr $displayed_generation + 1] 1
  }
}


proc play_generations {from to} {
  global displayed_generation stop_button ngenerations time_delay scale update_slider

  set stop_button 0
  set update_slider 0

  if {$displayed_generation != $from} {
    plot_generation $from 1
  }

  if {$from < $to} {
    set inc 1
  } else {
    set inc -1
  }

  while {$displayed_generation != $to && $stop_button == 0} {
    plot_generation [expr $displayed_generation + $inc] 1
    after $time_delay
  }

  $scale set $displayed_generation
  set update_slider 1
  set stop_button 0
}

proc print_canvas {} {
  global canvas

  $canvas postscript -colormode gray -file site-canvas.ps -pageheight 7i -pagewidth 7i
}
  
set_colors $ncolors $color_interval
read_rows_cols
initialize
draw_sites
update
set displayed_generation 0
read_input
set initialized 1
set displayed_generation -1
plot_generation 0 0
update

# Local Variables:
# mode:tcl
# End: ***
